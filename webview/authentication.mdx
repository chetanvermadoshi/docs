---
title: "Web View Authentication Guide"
description: "This guide explains how to implement secure webview-based authentication in web applications, specifically focusing on parent-child window communication using postMessage or query parameters."
---

## Security Considerations

1. **Origin Verification**
   - Always verify the origin of messages received from the webview
   - Implement proper message validation
   - Use HTTPS for secure communication

2. **Cross-Origin Communication**
   - Use `postMessage` API for secure cross-origin communication
   - Validate message sources
   - Implement proper error handling

3. **Query Parameter Security**
   - Sanitize and validate all query parameters
   - Avoid exposing sensitive data in URLs
   - Use short-lived tokens when passing credentials via query params

## Implementation Methods

### Method 1: postMessage API

#### TypeScript Interfaces

```typescript
interface AuthData {
  token: string;
  email: string;
  firstName: string;
  lastName: string;
  partnerUserId: string;
  pathId: string;
  segment: string;
  branchId: string;
}

interface WebviewMessage {
  type: string;
  [key: string]: any;
}
```

#### Parent Window - React Implementation

```tsx
import React, { useEffect, useState } from "react";

interface Props {
  authData: AuthData;
}

const WebviewComponent: React.FC<Props> = ({ authData }) => {
  const [isLoadingAuth, setIsLoadingAuth] = useState(false);

  useEffect(() => {
    // Setup message listener
    const handleMessage = (event: MessageEvent) => {
      // Verify origin in production
      // if (event.origin !== 'https://embed.doshi.app') return;
      
      try {
        const data: WebviewMessage =
          typeof event.data === "string" ? JSON.parse(event.data) : event.data;

        // When we receive PING from webview, send the auth data
        if (data.type === "PING") {
          handleSendAuth();
        }
      } catch (error) {
        console.error("Error processing message:", error);
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, []);

  const handleSendAuth = async () => {
    setIsLoadingAuth(true);

    // Filter out empty values from authData
    const filteredAuthData = Object.fromEntries(
      Object.entries(authData).filter(([_, value]) => value !== "")
    );

    // Find the webview and send message
    const webview = document.querySelector("iframe");
    if (webview && webview.contentWindow) {
      webview.contentWindow.postMessage(
        JSON.stringify({
          ...filteredAuthData,
          type: "AUTH",
        }),
        "*" // In production, specify exact origin: "https://embed.doshi.app"
      );
    }

    setIsLoadingAuth(false);
  };

  return (
    <div className="webview-container">
      <iframe
        src="https://embed.doshi.app"
        className="h-full w-full"
        frameBorder="0"
        allowFullScreen
      />
    </div>
  );
};

export default WebviewComponent;
```

#### Parent Window - Pure JavaScript Implementation

```javascript
// Define your auth data
const authData = {
  token: "",
  email: "",
  firstName: "",
  lastName: "",
  partnerUserId: "",
  pathId: "",
  segment: "",
  branchId: "",
};

// Create and add webview to the page
const webview = document.createElement("iframe");
webview.src = "https://embed.doshi.app";
webview.className = "h-full w-full";
webview.frameBorder = "0";
webview.allowFullscreen = true;

document.querySelector("#your-container-id").appendChild(webview);

// Handle messages from webview
function handleMessage(event) {
  // Verify origin in production
  // if (event.origin !== 'https://embed.doshi.app') return;
  
  try {
    const data =
      typeof event.data === "string" ? JSON.parse(event.data) : event.data;

    // When we receive PING from webview, send the auth data
    if (data.type === "PING") {
      // Filter out empty values from authData
      const filteredAuthData = Object.fromEntries(
        Object.entries(authData).filter(([_, value]) => value !== "")
      );

      // Send auth data to webview
      webview.contentWindow.postMessage(
        JSON.stringify({
          ...filteredAuthData,
          type: "AUTH",
        }),
        "*" // In production, specify exact origin
      );
    }
  } catch (error) {
    console.error("Error processing message:", error);
  }
}

// Add message listener
window.addEventListener("message", handleMessage);

// Clean up on page unload
window.addEventListener("beforeunload", () => {
  window.removeEventListener("message", handleMessage);
});
```

#### Child Window (Webview) - Sending Messages

```javascript
// Inside the webview, send PING to parent
window.parent.postMessage(
  JSON.stringify({ type: "PING" }),
  "*" // In production, specify parent origin
);

// Listen for AUTH response
window.addEventListener("message", (event) => {
  // Verify origin in production
  // if (event.origin !== 'https://parent-domain.com') return;
  
  try {
    const data = typeof event.data === "string" ? JSON.parse(event.data) : event.data;
    
    if (data.type === "AUTH") {
      // Process authentication data
      const { token, email, firstName, lastName } = data;
      // Handle authentication
    }
  } catch (error) {
    console.error("Error processing auth message:", error);
  }
});
```

### Method 2: Query Parameters

#### Parent Window - React Implementation

```tsx
import React, { useEffect, useMemo } from "react";

interface Props {
  authData: AuthData;
}

const WebviewWithQueryParams: React.FC<Props> = ({ authData }) => {
  // Build URL with query parameters
  const webviewUrl = useMemo(() => {
    const baseUrl = "https://embed.doshi.app";
    const params = new URLSearchParams();
    
    // Add non-empty auth data to query params
    Object.entries(authData).forEach(([key, value]) => {
      if (value) {
        params.append(key, value);
      }
    });
    
    return `${baseUrl}?${params.toString()}`;
  }, [authData]);

  return (
    <div className="webview-container">
      <iframe
        src={webviewUrl}
        className="h-full w-full"
        frameBorder="0"
        allowFullScreen
      />
    </div>
  );
};

export default WebviewWithQueryParams;
```

#### Parent Window - Pure JavaScript Implementation

```javascript
// Define your auth data
const authData = {
  token: "user_token_123",
  email: "user@example.com",
  firstName: "John",
  lastName: "Doe",
  partnerUserId: "partner_123",
  pathId: "path_456",
  segment: "premium",
  branchId: "branch_789",
};

// Build URL with query parameters
function buildWebviewUrl(baseUrl, data) {
  const params = new URLSearchParams();
  
  // Add non-empty values to query params
  Object.entries(data).forEach(([key, value]) => {
    if (value) {
      params.append(key, value);
    }
  });
  
  return `${baseUrl}?${params.toString()}`;
}

// Create and add webview to the page
const webview = document.createElement("iframe");
webview.src = buildWebviewUrl("https://embed.doshi.app", authData);
webview.className = "h-full w-full";
webview.frameBorder = "0";
webview.allowFullscreen = true;

document.querySelector("#your-container-id").appendChild(webview);
```

#### Child Window (Webview) - Reading Query Parameters

```javascript
// Inside the webview, extract query parameters
function getAuthDataFromUrl() {
  const params = new URLSearchParams(window.location.search);
  
  return {
    token: params.get('token') || '',
    email: params.get('email') || '',
    firstName: params.get('firstName') || '',
    lastName: params.get('lastName') || '',
    partnerUserId: params.get('partnerUserId') || '',
    pathId: params.get('pathId') || '',
    segment: params.get('segment') || '',
    branchId: params.get('branchId') || '',
  };
}

// Use the auth data
const authData = getAuthDataFromUrl();
console.log('Authenticated user:', authData.email);

// Optionally, clear sensitive params from URL after reading
if (window.history.replaceState) {
  const url = new URL(window.location.href);
  url.search = ''; // Clear all query params
  window.history.replaceState({}, document.title, url.toString());
}
```

#### Advanced: Combining Both Methods

```tsx
import React, { useEffect, useState, useMemo } from "react";

interface Props {
  authData: AuthData;
  useQueryParams?: boolean; // Toggle between methods
}

const FlexibleWebview: React.FC<Props> = ({ authData, useQueryParams = false }) => {
  const [isLoadingAuth, setIsLoadingAuth] = useState(false);

  // Build URL with query params if needed
  const webviewUrl = useMemo(() => {
    const baseUrl = "https://embed.doshi.app";
    
    if (!useQueryParams) {
      return baseUrl;
    }
    
    const params = new URLSearchParams();
    Object.entries(authData).forEach(([key, value]) => {
      if (value) params.append(key, value);
    });
    
    return `${baseUrl}?${params.toString()}`;
  }, [authData, useQueryParams]);

  // postMessage handler
  useEffect(() => {
    if (useQueryParams) return; // Skip if using query params
    
    const handleMessage = (event: MessageEvent) => {
      try {
        const data: WebviewMessage =
          typeof event.data === "string" ? JSON.parse(event.data) : event.data;

        if (data.type === "PING") {
          handleSendAuth();
        }
      } catch (error) {
        console.error("Error processing message:", error);
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, [useQueryParams]);

  const handleSendAuth = async () => {
    setIsLoadingAuth(true);

    const filteredAuthData = Object.fromEntries(
      Object.entries(authData).filter(([_, value]) => value !== "")
    );

    const webview = document.querySelector("iframe");
    if (webview && webview.contentWindow) {
      webview.contentWindow.postMessage(
        JSON.stringify({
          ...filteredAuthData,
          type: "AUTH",
        }),
        "*"
      );
    }

    setIsLoadingAuth(false);
  };

  return (
    <div className="webview-container">
      <iframe
        src={webviewUrl}
        className="h-full w-full"
        frameBorder="0"
        allowFullScreen
      />
    </div>
  );
};

export default FlexibleWebview;
```

## Best Practices

1. **Security**
   - Always use HTTPS
   - Implement proper origin checks (for postMessage)
   - Validate all messages and parameters
   - Use short-lived tokens
   - **Replace `"*"` wildcard with specific origins in production**
   - Consider clearing sensitive query params after reading

2. **Error Handling**
   - Implement comprehensive error handling
   - Log authentication failures
   - Provide user feedback
   - Handle timeout scenarios

3. **Performance**
   - Minimize cross-frame communication
   - Use efficient message formats
   - Implement proper cleanup
   - Cache authentication state when appropriate

4. **Method Selection**
   - **Use postMessage** for:
     - Real-time communication
     - Sensitive data that shouldn't be in URLs
     - Dynamic authentication flows
     - Better security control
   - **Use query parameters** for:
     - Simple, one-time authentication
     - Stateless authentication
     - Easier debugging (visible in URL)
     - Simpler implementation

## Styling Best Practices

```css
.webview-container {
  /* Responsive container */
  width: 100%;
  height: 900px;
  overflow: hidden;
}

.webview-container iframe {
  /* Full dimensions */
  width: 100%;
  height: 100%;
  border: none;
}
```

## Common Issues and Solutions

1. **Cross-Origin Issues**
   - Solution: Proper CORS configuration
   - Use allowlisted origins
   - Configure appropriate headers
   - Verify origin in message handlers

2. **Message Security**
   - Solution: Implement origin validation
   - Always validate message structure
   - Never use `"*"` as target origin in production
   - Parse and validate all incoming data

3. **Query Parameter Length Limits**
   - Solution: Use short tokens or token references
   - Consider postMessage for large data transfers
   - Implement server-side token storage
   - URLs should generally stay under 2000 characters

4. **Sensitive Data Exposure**
   - Solution: Avoid putting tokens directly in URLs
   - Use temporary access codes with query params
   - Clear URL parameters after reading
   - Prefer postMessage for sensitive data

5. **Browser Compatibility**
   - Solution: Test across different browsers
   - postMessage is widely supported
   - URLSearchParams has good support (polyfill for older browsers)
   - Implement fallback mechanism